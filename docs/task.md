**Техническое задание на сервис LogShelter**

---

### 1. Общее описание

**Название сервиса**: **LogShelter**  
**Назначение**: Централизованное хранение, индексирование и выборка структурированных логов от распределённых приложений с поддержкой фильтрации, пагинации и батчевой записи через NATS.

---

### 2. Архитектурные компоненты

- **Сообщения между компонентами**: NATS (в роли message bus / event backbone)
- **Хранилище данных**: PostgreSQL (основная БД для хранения логов)
- **Кэширование**: Redis (для ускорения повторных запросов, например — кэширование результатов фильтрации по request_id)
- **Формат сообщений**: BSON (Binary JSON)

---

### 3. NATS Subjects (ручки)

#### 3.1. `log_shelter.append`

- **Назначение**: Приём одиночной записи лога от клиента.
- **Формат входного сообщения (BSON)**:
  ```json
  {
    "raw_log": "string",          // обязательное
    "log_level": "string",        // обязательное
    "source": "string",           // обязательное (например: "auth-service/v1.2")
    "created_at": "timestamp",    // обязательное (RFC3339 или Unix)
    "request_id": "string",       // опционально
    "logger_name": "string",      // опционально
    "is_deleted": "bool"          // опционально, по умолчанию false
  }
  ```
- **Поведение**:  
  Сервис принимает сообщение и помещает его во внутреннюю очередь для батчинга.  
  В течение **1 секунды** собираются все поступившие логи и отправляются в `log_shelter.__internal__.append`.

#### 3.2. `log_shelter.__internal__.append`

- **Назначение**: Внутренний subject для батчевой записи в БД.
- **Формат входного сообщения (BSON)**:
  ```json
  {
    "batch": [
      { /* структура как в log_shelter.append */ },
      ...
    ]
  }
  ```
- **Поведение**:  
  Сервис записывает весь батч в PostgreSQL одной транзакцией.  
  Ошибки обрабатываются с логированием и повторной попыткой (retry) при необходимости.

#### 3.3. `log_shelter.get`

- **Назначение**: Выборка логов по фильтрам с пагинацией.
- **Формат входного сообщения (BSON)**:
  ```json
  {
    "page": 1,                    // обязательное, >=1
    "page_size": 50,              // опционально, по умолчанию 50
    "sources": ["*", "auth-service", ...], // опционально, "*" = все источники
    "levels": ["error", "warn"],  // опционально
    "before": "timestamp",        // опционально
    "after": "timestamp",         // опционально
    "request_id": "string",       // опционально
    "logger_name": "string",      // опционально
    "order": "asc" | "desc"       // опционально, по умолчанию "desc"
  }
  ```
- **Формат ответа (BSON)**:
  ```json
  {
    "data": [ /* массив логов в том же формате, что и на входе */ ],
    "remaining": 123,             // сколько записей осталось после текущей страницы
    "total": 1024                 // общее количество записей по фильтру
  }
  ```
- **Особенности**:
  - Поддержка кэширования в Redis по хэшу параметров запроса (TTL = 30 сек).
  - Все фильтры комбинируются по логике AND.
  - Сортировка всегда по полю `created_at`.

---

### 4. Требования к БД (PostgreSQL)

- Таблица `logs`:
  ```sql
  id BIGSERIAL PRIMARY KEY,
  raw_log TEXT NOT NULL,
  log_level VARCHAR(16) NOT NULL,
  source VARCHAR(128) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL,
  request_id VARCHAR(64),
  logger_name VARCHAR(128),
  is_deleted BOOLEAN DEFAULT false
  ```
- Индексы:
  - `(created_at DESC)`
  - `(source, created_at)`
  - `(request_id)` — частичный индекс WHERE request_id IS NOT NULL
  - `(log_level, created_at)`

---

### 5. Нефункциональные требования

- **Производительность**:  
  - Запись: до 10 000 логов/сек (с батчингом).  
  - Чтение: ответ за <500 мс при выборке до 1000 записей.
- **Надёжность**:  
  - Потеря логов недопустима — гарантия доставки через NATS JetStream (если используется) или внутреннюю очередь с подтверждением.
- **Масштабируемость**:  
  - Возможность горизонтального масштабирования consumer'ов NATS.
- **Безопасность**:  
  - NATS подключается по TLS, аутентификация по credentials.

---

### 6. Дополнительно

- Имя `LogShelter` отражает идею «убежища» для логов — надёжного, структурированного и защищённого хранилища.
- NATS используется как **асинхронная шина событий** между клиентами и внутренними компонентами сервиса.

--- 

Готово к передаче в разработку.