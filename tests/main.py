import asyncio
import datetime
import json
import nats

from nats.aio.client import Client
"""
Here will be integration tests
"""

import datetime
import uuid
import random


def generate_test_logs() -> list[dict]:
    """
        Generated by gpt. Just for local feature test.
    """
    # 1. Создаём "критический" лог с известным id = 1333337
    critical_time = datetime.datetime.now(tz=datetime.UTC)  # например
    critical_request_id = str(uuid.uuid4())
    critical_source = "auth-service"
    critical_logger = "AuthLogger"

    critical_log = {
        "raw": "Critical auth failure",
        "level": "CRITICAL",
        "source": critical_source,
        "created_at": critical_time,
        "request_id": critical_request_id,
        "logger_name": critical_logger,
    }

    logs = [critical_log]

    # 2. Добавим логи с тем же request_id (должны попасть в результат)
    for i in range(3):
        logs.append({
            "raw": f"Related log #{i}",
            "level": random.choice(["ERROR", "WARN"]),
            "source": random.choice(["auth-service", "api-gateway"]),
            "created_at": critical_time + datetime.timedelta(seconds=random.randint(-10, 10)),
            "request_id": critical_request_id,  # ← тот же!
            "logger_name": f"Logger{i}",
        })

    # 3. Добавим логи из того же source в пределах [-5m, +1m] (должны попасть)
    for i in range(5):
        # случайное время в окне: от -5 мин до +1 мин
        offset_sec = random.randint(-5 * 60, 1 * 60)
        log_time = critical_time + datetime.timedelta(seconds=offset_sec)
        logs.append({
            "raw": f"Same source log #{i}",
            "level": random.choice(["ERROR", "FATAL", "WARN"]),
            "source": critical_source,  # ← тот же source!
            "created_at": log_time,
            "request_id": str(uuid.uuid4()),  # другой request_id
            "logger_name": f"AuthLogger{i}",
        })

    # 4. Добавим "шум" — логи, которые НЕ должны попасть в результат
    noise_sources = ["payment-service", "email-worker"]
    for i in range(10):
        logs.append({
            "raw": f"Noise log #{i}",
            "level": random.choice(["INFO", "DEBUG", "ERROR"]),
            "source": random.choice(noise_sources),
            "created_at": critical_time + datetime.timedelta(seconds=random.randint(-10, 10)),
            "request_id": str(uuid.uuid4()),
            "logger_name": "NoiseLogger",
        })

    # 5. Добавим логи с правильным уровнем, но вне временного окна
    logs.append({
        "raw": "Same source, but too early",
        "level": "ERROR",
        "source": critical_source,
        "created_at": critical_time - datetime.timedelta(seconds=6),  # ← раньше -5m
        "request_id": None,
        "logger_name": "AuthLogger",
    })

    logs.append({
        "raw": "Same source, but too late",
        "level": "ERROR",
        "source": critical_source,
        "created_at": critical_time + datetime.timedelta(seconds=2),  # ← позже +1m
        "request_id": None,
        "logger_name": "AuthLogger",
    })

    return logs

def make_request(
        raw: str,
        level: str,
        source: str,
        created_at: datetime.datetime,
        request_id: str | None = None,
        logger_name: str | None = None        
) -> str:
    d = {
        "raw_log": raw,
        "log_level": level,
        "source": source,
        "created_at": created_at.isoformat()} 
    if request_id is not None:
        d["reuqest_id"] = request_id
    if logger_name is not None:
        d["logger_name"] = logger_name
    return json.dumps(d)

async def get_nc() -> Client:
    return await nats.connect(servers = "nats://localhost:4222", user = "nats", password = "nats")

async def main():
    nc = await get_nc()

    data = generate_test_logs()
    data = [make_request(**i) for i in data]
    
    """tasks = [
        nc.publish("nats.hi",
                   payload = i.encode())
                   for i in data
    ]"""

    #await asyncio.gather(*tasks)

    res = await nc.request("nats.bye", payload = b"""{  "page": 1,  "levels": ["*"],  "sources": ["*"], "order": "asc"}""")
    print(res)
    
    print("_______")

    res = await nc.request("nats.timeline", payload = b"""{ "id": 61 }""")
    print(res)
    await nc.close()

if __name__ == '__main__':
    asyncio.run(main())
